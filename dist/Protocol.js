!function(){function n(t){var r=e[t];return"string"==typeof r&&Function("module","exports","require","eval("+JSON.stringify(r+"\n//@ sourceURL=/"+t)+")").call((e[t]=r={exports:{}}).exports,r,r.exports,n),r.exports}var e=["module.exports = Protocol\n\nvar getProto = Object.getPrototypeOf\n\n/**\n * Create a new kind of abstraction\n *\n *   var Enumerable = createProtocol({\n *     first: function(){return this.value[0]},\n *     each: function(fn){\n *       for (var i = 0; i < this.value.length; i++) {\n *         fn(this.value[i])\n *       }\n *       return this\n *     }\n *   })\n *  \n * @param {Object} ui The default set of methods each implementation will recieve \n * @return {Function} [description]\n */\n\nfunction Protocol (ui) {\n	var types = []\n	  , imps = []\n\n	ui || (ui = {})\n\n	function dispatcher (value) {\n		var Wrapper = get(value.constructor)\n		if (Wrapper) return new Wrapper(value) \n	}\n	/**\n	 * Get the implementation of a certain type if it has one\n	 *\n	 *   enumerable.get(Array) -> [Function ArrayWrapper]\n	 *\n	 * @param {Constructor} type\n	 * @return {Constructor} the function used to generate wrappers for the type passed\n	 */\n	dispatcher.get = get\n	function get (type) {\n		do {\n			var i = types.length\n			while (i--) \n				if (types[i] === type) return imps[i]\n		} while ((type = getProto(type.prototype)) && (type = type.constructor))\n	}\n\n	/**\n	 * Add an implementation for type to the protocol\n	 *\n	 *   enumerable.implement(String, function(value){\n	 *     this.value = value\n	 *   })\n	 *\n	 * @param {Constructor} type the constructor of the type you are adding to the protocol\n	 * @param {Constructor} factory The type that will implement the interface\n	 * @return {Self}\n	 */\n\n	dispatcher.implement = function (type, factory) {\n		if (types.indexOf(type) >= 0) {\n			throw new Error('Protocol already implemented for '+(type.name || type))\n		}\n		if (typeof factory !== 'function') {\n			var proto = factory\n			factory = function Wrapper (value) {this.value = value}\n			if (typeof proto === 'object') merge(factory.prototype, proto)\n		}\n		var proto = factory.prototype\n		  , methods = Object.keys(ui)\n		  , i = methods.length\n		while (i--) {\n			if (typeof proto[methods[i]] !== 'function') {\n				proto[methods[i]] = ui[methods[i]]\n			}\n		}\n		types.push(type)\n		imps.push(factory)\n		return this\n	}\n	/**\n	 * Add methods to the protocols interface\n	 *\n	 *   enumerable.extend({\n	 *     toArray: function(){\n	 *       return Array.apply(null, this.value)\n	 *     }\n	 *   })\n	 *\n	 * @param {Constructor} type If you only want to extend the interface of a certain type\n	 * @param {Object} add an object containing the methods to add\n	 * @return {Self}\n	 */\n	dispatcher.extend = function (type, add) {\n		if (add == null) {\n			merge(ui, type)\n			var i = types.length\n			while (i--) {\n				this.extend(types[i], type)\n			}\n		}\n		else {\n			var i = types.indexOf(type)\n			if (i < 0) \n				throw new Error('No implmentation is defined for '+ (type.name || type))\n			merge(imps[i].prototype, add)\n		}\n		return this\n	}\n\n	return dispatcher\n}\n\nfunction merge (a, b) {\n	var keys = Object.keys(b)\n	  , i = keys.length\n	while (i--) {\n		a[keys[i]] = b[keys[i]]\n	}\n}\n\n//@ sourceURL=/home/jkroso/Dev/Libraries/Protocol/src/index.js"];Protocol=n(0)}();